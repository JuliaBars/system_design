# Эволюция системы

## I этап один сервер с приложением

## II этап добавление БД (знать где взять реляционную, а где нереляционную)

Где нереляционные БД лучше:

- Огромный объем данных (Big Data, высокая скорость поступления)
- Неструктурированные, полуструктурированные или разнородные данные
- Горизонтальное масштабирование (распределение по множеству серверов)
- Гибкая, быстро меняющаяся схема данных
- Высокие требования к производительности операций чтения/записи

### Примеры сервисов с нереляционными БД

1. **Система рекомендаций для стримингового сервиса (например, как у Netflix или Spotify)**

- Гибкая схема: Легко добавлять новые поля (например, "mood_today") для A/B-тестирования алгоритмов без дорогостоящих миграций БД.
- Производительность: Быстрая запись и чтение всего профиля целиком, что критично для обновления рекомендаций в реальном времени.
- Масштабируемость: Легко распределять данные о пользователях по разным серверам по мере роста аудитории

2. **Платформа для сбора и анализа данных с IoT-устройств (умный дом, промышленные датчики)**

- Оптимизация под временные ряды: NoSQL-базы, такие как InfluxDB, эффективно сжимают и хранят последовательные данные по времени, что позволяет хранить годы высокочастотных показаний.
- Скорость записи: Обрабатывают огромные объемы вставок (миллионы событий в секунду), что нереально для традиционных реляционных баз.
- Эффективные запросы по времени: Специализированные запросы для выборки данных за определенный период, агрегации (среднее, макс., мин.) и анализа трендов.

3. **Соцсеть (например LinkedIn)**

- Модель данных "в лоб": Данные хранятся именно как граф, что интуитивно соответствует предметной области (социальный граф).
- Производительность на обходах графа: Запросы, требующие прохода по нескольким уровням связей (например, "друзья 3-го уровня"), выполняются на порядки быстрее, чем в SQL с использованием множественных JOIN (которые становятся очень "тяжелыми" на большой глубине).
- Гибкость связей: Легко добавлять новые типы связей (например, "ПОДПИСАН_НА", "ПРОШЕЛ_КУРС") без изменения схемы таблиц.

## III этап добавление балансировщика нагрузки и нескольких инстансов приложения

Приложения не хранят состояние, состояние может храниться в БД или передаваться с запросом (сессия пользователя в БД, токены с запросом)

## IV этап добавление реплики БД

- ведущая БД пишет
- ведомые только читают

## V этап добавление слоя кеширования

- инвалидация кеша
- кешируем часто только запросы чтения (риск потери данных)
- рассчитывать разумный срок жизни кеша
- переполнение кеша (вытеснение LRU)

## VI этап перенос статики в CDN

- должны быть механизмы работы, если CDN вышел из строя
- версионирование объектов

## VII этап добавление центров обработки данных (содержащие в себе все описанное выше)

- active-passive архитектура когда один ЦОД простаивает и находится в разной степени готовности к старту, в случае падения основного
- active-active все цод активны и готовы подменить друг друг (архитектура Netflix)

## VIII этап добавление очередей

## IX этап логирование, метрики, автоматизация

## IX этап шардирование (сегментирование) БД

- повторное шардирование переполненного участка
- проблема неудачного ключа или слишком большого количества записей по одному ключу
- сложно агрегировать данные с разных шардов
