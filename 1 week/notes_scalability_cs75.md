# Мысли и идеи после прочтения / просмотра

## Vertical scaling

- упирается в деньги компании
- или в возможности железа на данный момент

## Horizontal scaling

- много недорогих машин могут работать быстрее, чем 1 большая и дорогая

## Caching

Использование кеша:

Пользователь (0.1 мс)\
├── Browser Cache (1-10 мс)\
├── CDN Edge (5-50 мс)\
├── Reverse Proxy Cache (0.5-5 мс)\
├── Application Cache (0.01-1 мс)\
├── Distributed Cache (1-10 мс)\
├── Database Cache (0.1-10 мс)\
└── Persistent Storage (5-100+ мс)

Без кеша:

Время загрузки = 500-2000+ мс
Этапы:

1. DNS Lookup:                    50 мс ❌
2. TCP Handshake (3-way):         60 мс ❌
3. TLS Handshake:                 100 мс ❌  
4. HTTP запрос за HTML:           100 мс ❌
5. Парсинг HTML, запрос CSS/JS:   50 мс ❌
6. Загрузка 10 изображений:       500+ мс ❌
7. API запрос за данными товара:  200 мс ❌
8. SQL запрос к БД:               50 мс ❌
9. Запрос рекомендаций:           100 мс ❌
10. Рендеринг в браузере:         100 мс ❌

---
ИТОГО: ~1300+ мс (1.3+ секунды)

Правило 80/20 в кешировании:

- 20% усилий на настройку кеша = 80% улучшения производительности
- Первые 2-3 уровня (Browser + CDN) дают 70-90% выгоды
- Остальные уровни оптимизируют "последнюю милю"

Google Research:

- 0-100 мс: Идеально (пользователь не замечает)
- 100-300 мс: Приемлемо
- 300-1000 мс: Пользователь замечает задержку
- 1-3 секунды: Внимание начинает блуждать
- 3+ секунды: 40% пользователей уходят

Amazon:

- Каждые 100 мс задержки = -1% продаж

Walmart:

- Улучшение на 1 секунду = +2% конверсия

BBC:

- Каждая дополнительная секунда = +10% отказов

При изменении данных, предпочтительно публиковать событие, сервисы отвечающие за инвалидацию кеша должны слушать эти события и удалять или обновлять кеш

Но есть и другие стратегии инвалидации (cache_invalidations.png)

## Load balancing

- некоторая доп защита от того что приватные IP адреса не нужно выставлять наружу, наружу открыт только публичный адрес балансировщика
- балансировщика должно быть тоже минимум 2, по принципу active-active, active-passive
- множество разных алгоритмов (знать хотя бы 5-6)
- Sticky sessions — это техника прошлого, которая все еще существует по историческим причинам, но противоречит принципам cloud-native, горизонтального масштабирования и отказоустойчивости

## Database replication

- балансируем между тратами на реплики, потерями данных, скоростью восстановления
- перед доступам к репликам тоже стоит балансировщик
- master-slaves, master-master, voting

## Database partitioning

- не просто выбрать по какому признаку делить на партиции
